/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CalendarPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  sources: [
    {
      id: "watched",
      name: "Watched",
      folder: "shows/watched",
      color: "#e74c3c",
      dateField: "date",
      titleField: "show",
      enabled: true,
      displayFields: [
        { field: "type", label: "", format: "none" },
        { field: "episodeTitle", label: "", format: "none" }
      ]
    },
    {
      id: "workouts",
      name: "Workouts",
      folder: "health/workouts",
      color: "#f1c40f",
      dateField: "date",
      titleField: "workoutType",
      enabled: true,
      displayFields: [
        { field: "totalTime", label: "", format: "duration" },
        { field: "distance", label: "", format: "number", unitField: "distanceUnit" }
      ]
    }
  ],
  defaultView: "month",
  showWeekNumbers: false,
  startWeekOn: "monday"
};
function formatDuration(minutes) {
  if (minutes < 60) {
    return `${Math.round(minutes)} min`;
  }
  const hours = Math.floor(minutes / 60);
  const mins = Math.round(minutes % 60);
  if (mins === 0) {
    return `${hours}h`;
  }
  return `${hours}h ${mins}m`;
}
function formatFieldValue(value, field, metadata) {
  if (value === void 0 || value === null) {
    return "";
  }
  let displayValue = "";
  const numValue = typeof value === "number" ? value : parseFloat(String(value));
  switch (field.format) {
    case "duration":
      if (!isNaN(numValue)) {
        displayValue = formatDuration(numValue);
      } else {
        displayValue = String(value);
      }
      break;
    case "number":
      displayValue = String(value);
      break;
    default:
      displayValue = String(value);
      const linkMatch = displayValue.match(/\[\[(?:[^\]|]+\|)?([^\]]+)\]\]/);
      if (linkMatch) {
        displayValue = linkMatch[1];
      }
  }
  if (field.unitField && metadata[field.unitField]) {
    displayValue += ` ${metadata[field.unitField]}`;
  } else if (field.unit) {
    displayValue += ` ${field.unit}`;
  }
  if (field.label) {
    displayValue = `${field.label}: ${displayValue}`;
  }
  return displayValue;
}
function generateSourceId() {
  return "source-" + Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
}

// src/settings.ts
var import_obsidian = require("obsidian");

// src/utils/colorUtils.ts
var COLOR_PALETTE = [
  "#e74c3c",
  // Red
  "#f1c40f",
  // Yellow
  "#2ecc71",
  // Green
  "#3498db",
  // Blue
  "#9b59b6",
  // Purple
  "#e67e22",
  // Orange
  "#1abc9c",
  // Teal
  "#34495e",
  // Dark Gray
  "#e91e63",
  // Pink
  "#00bcd4"
  // Cyan
];

// src/settings.ts
var CalendarSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Calendar View Settings" });
    new import_obsidian.Setting(containerEl).setName("Refresh calendar").setDesc("Rescan all sources and reload the calendar view").addButton((button) => button.setButtonText("Refresh").onClick(async () => {
      button.setButtonText("Refreshing...");
      button.setDisabled(true);
      await this.plugin.scanner.scanSources(this.plugin.settings.sources);
      const view = this.plugin.getCalendarView();
      if (view && typeof view.refresh === "function") {
        await view.refresh();
      }
      button.setButtonText("Refresh");
      button.setDisabled(false);
      new import_obsidian.Notice("Calendar refreshed");
    }));
    new import_obsidian.Setting(containerEl).setName("Export settings").setDesc("Download your calendar sources and display fields as a JSON file").addButton((button) => button.setButtonText("Export").onClick(() => {
      const settings = {
        sources: this.plugin.settings.sources,
        defaultView: this.plugin.settings.defaultView,
        showWeekNumbers: this.plugin.settings.showWeekNumbers,
        startWeekOn: this.plugin.settings.startWeekOn
      };
      const blob = new Blob([JSON.stringify(settings, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "calendar-settings.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      new import_obsidian.Notice("Settings exported");
    }));
    new import_obsidian.Setting(containerEl).setName("Import settings").setDesc("Load calendar sources and display fields from a JSON file").addButton((button) => button.setButtonText("Import").onClick(() => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".json";
      input.onchange = async (e) => {
        var _a;
        const file = (_a = e.target.files) == null ? void 0 : _a[0];
        if (!file) return;
        try {
          const text = await file.text();
          const imported = JSON.parse(text);
          if (!imported.sources || !Array.isArray(imported.sources)) {
            new import_obsidian.Notice("Invalid settings file: missing sources");
            return;
          }
          this.plugin.settings.sources = imported.sources;
          if (imported.defaultView) this.plugin.settings.defaultView = imported.defaultView;
          if (imported.showWeekNumbers !== void 0) this.plugin.settings.showWeekNumbers = imported.showWeekNumbers;
          if (imported.startWeekOn) this.plugin.settings.startWeekOn = imported.startWeekOn;
          await this.plugin.saveSettings();
          this.display();
          new import_obsidian.Notice("Settings imported successfully");
        } catch (err) {
          new import_obsidian.Notice("Failed to import settings: " + err.message);
        }
      };
      input.click();
    }));
    this.addGeneralSettings(containerEl);
    containerEl.createEl("h3", { text: "Calendar Sources" });
    containerEl.createEl("p", {
      text: "Configure folders to display on the calendar. Notes in these folders will be shown based on their date frontmatter field.",
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).setName("Add new source").setDesc("Add a new folder to track on the calendar").addButton((button) => button.setButtonText("Add Source").setCta().onClick(async () => {
      const newSource = {
        id: generateSourceId(),
        name: "New Source",
        folder: "",
        color: COLOR_PALETTE[this.plugin.settings.sources.length % COLOR_PALETTE.length],
        dateField: "date",
        enabled: true
      };
      this.plugin.settings.sources.push(newSource);
      await this.plugin.saveSettings();
      this.display();
    }));
    const sourcesContainer = containerEl.createDiv("calendar-sources-container");
    this.plugin.settings.sources.forEach((source, index) => {
      this.addSourceSettings(sourcesContainer, source, index);
    });
  }
  addGeneralSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Default view").setDesc("Choose the default calendar view when opening").addDropdown((dropdown) => dropdown.addOption("month", "Month").addOption("week", "Week").addOption("list", "List").setValue(this.plugin.settings.defaultView).onChange(async (value) => {
      this.plugin.settings.defaultView = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Start week on").setDesc("Choose which day the week starts on").addDropdown((dropdown) => dropdown.addOption("sunday", "Sunday").addOption("monday", "Monday").setValue(this.plugin.settings.startWeekOn).onChange(async (value) => {
      this.plugin.settings.startWeekOn = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show week numbers").setDesc("Display week numbers in the calendar").addToggle((toggle) => toggle.setValue(this.plugin.settings.showWeekNumbers).onChange(async (value) => {
      this.plugin.settings.showWeekNumbers = value;
      await this.plugin.saveSettings();
    }));
  }
  addSourceSettings(containerEl, source, index) {
    const sourceContainer = containerEl.createDiv("calendar-source-item");
    sourceContainer.style.border = "1px solid var(--background-modifier-border)";
    sourceContainer.style.borderRadius = "8px";
    sourceContainer.style.padding = "12px";
    sourceContainer.style.marginBottom = "12px";
    sourceContainer.style.borderLeft = `4px solid ${source.color}`;
    const headerSetting = new import_obsidian.Setting(sourceContainer).setName(source.name || "Unnamed Source").addToggle((toggle) => toggle.setValue(source.enabled).setTooltip("Enable/disable this source").onChange(async (value) => {
      source.enabled = value;
      await this.plugin.saveSettings();
    })).addExtraButton((button) => button.setIcon("trash").setTooltip("Delete source").onClick(async () => {
      this.plugin.settings.sources.splice(index, 1);
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian.Setting(sourceContainer).setName("Name").setDesc("Display name for this source").addText((text) => text.setPlaceholder("e.g., Watched").setValue(source.name).onChange(async (value) => {
      source.name = value;
      headerSetting.setName(value || "Unnamed Source");
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(sourceContainer).setName("Folder").setDesc("Path to the folder containing notes").addText((text) => text.setPlaceholder("e.g., shows/watched").setValue(source.folder).onChange(async (value) => {
      source.folder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(sourceContainer).setName("Color").setDesc("Color for events from this source").addColorPicker((picker) => picker.setValue(source.color).onChange(async (value) => {
      source.color = value;
      sourceContainer.style.borderLeft = `4px solid ${value}`;
      await this.plugin.saveSettings();
    })).addDropdown((dropdown) => {
      COLOR_PALETTE.forEach((color, i) => {
        dropdown.addOption(color, `Preset ${i + 1}`);
      });
      dropdown.setValue(source.color);
      dropdown.onChange(async (value) => {
        source.color = value;
        sourceContainer.style.borderLeft = `4px solid ${value}`;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(sourceContainer).setName("Date field").setDesc("Frontmatter field containing the date").addText((text) => text.setPlaceholder("date").setValue(source.dateField).onChange(async (value) => {
      source.dateField = value || "date";
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(sourceContainer).setName("Title field (optional)").setDesc("Frontmatter field to use as event title (defaults to filename)").addText((text) => text.setPlaceholder("e.g., show, workoutType").setValue(source.titleField || "").onChange(async (value) => {
      source.titleField = value || void 0;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(sourceContainer).setName("Image field (optional)").setDesc("Frontmatter field containing image path (for list view thumbnails)").addText((text) => text.setPlaceholder("e.g., cover, localCoverImage, poster").setValue(source.imageField || "").onChange(async (value) => {
      source.imageField = value || void 0;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(sourceContainer).setName("Image from linked note (optional)").setDesc('If image is on a linked note, specify link field(s) to try. Use comma-separated values to try multiple fields (e.g., "movie, show"). First match wins.').addText((text) => text.setPlaceholder("e.g., movie, show").setValue(source.imageFromLinkedNote || "").onChange(async (value) => {
      source.imageFromLinkedNote = value || void 0;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(sourceContainer).setName("Highlight field (optional)").setDesc('Show this field in a colored box (same size as thumbnails). Use comma-separated values for fallbacks (e.g., "timeAsleep, restingHeartRate"). First available value wins.').addText((text) => text.setPlaceholder("e.g., timeAsleep, restingHeartRate").setValue(source.highlightField || "").onChange(async (value) => {
      source.highlightField = value || void 0;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(sourceContainer).setName("Highlight format").setDesc("How to format the highlight value").addDropdown((dropdown) => dropdown.addOption("none", "None (as-is)").addOption("duration", "Duration (minutes \u2192 Xh Ym)").addOption("number", "Number").setValue(source.highlightFormat || "none").onChange(async (value) => {
      source.highlightFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(sourceContainer).setName("Highlight unit (optional)").setDesc('Unit to append. Use comma-separated values to match highlight fields (e.g., "km, min" matches "distance, totalTime")').addText((text) => text.setPlaceholder("e.g., km, min").setValue(source.highlightUnit || "").onChange(async (value) => {
      source.highlightUnit = value || void 0;
      await this.plugin.saveSettings();
    }));
    const displayFieldsContainer = sourceContainer.createDiv("calendar-display-fields");
    displayFieldsContainer.createEl("h4", { text: "Display Fields", cls: "calendar-display-fields-title" });
    const displayFieldsDesc = displayFieldsContainer.createEl("p", {
      text: "Configure additional fields to show in calendar events",
      cls: "setting-item-description"
    });
    if (!source.displayFields) {
      source.displayFields = [];
    }
    new import_obsidian.Setting(displayFieldsContainer).addButton((button) => button.setButtonText("Add Display Field").onClick(async () => {
      source.displayFields = source.displayFields || [];
      source.displayFields.push({
        field: "",
        label: "",
        format: "none"
      });
      await this.plugin.saveSettings();
      this.display();
    }));
    source.displayFields.forEach((displayField, fieldIndex) => {
      this.addDisplayFieldSettings(displayFieldsContainer, source, displayField, fieldIndex);
    });
    if (this.plugin.settings.sources.length > 1) {
      const moveContainer = new import_obsidian.Setting(sourceContainer).setName("Reorder").setDesc("Change the display order");
      if (index > 0) {
        moveContainer.addExtraButton((button) => button.setIcon("arrow-up").setTooltip("Move up").onClick(async () => {
          const temp = this.plugin.settings.sources[index - 1];
          this.plugin.settings.sources[index - 1] = source;
          this.plugin.settings.sources[index] = temp;
          await this.plugin.saveSettings();
          this.display();
        }));
      }
      if (index < this.plugin.settings.sources.length - 1) {
        moveContainer.addExtraButton((button) => button.setIcon("arrow-down").setTooltip("Move down").onClick(async () => {
          const temp = this.plugin.settings.sources[index + 1];
          this.plugin.settings.sources[index + 1] = source;
          this.plugin.settings.sources[index] = temp;
          await this.plugin.saveSettings();
          this.display();
        }));
      }
    }
  }
  addDisplayFieldSettings(containerEl, source, displayField, index) {
    const fieldContainer = containerEl.createDiv("calendar-display-field-item");
    fieldContainer.style.padding = "8px";
    fieldContainer.style.marginBottom = "8px";
    fieldContainer.style.background = "var(--background-secondary)";
    fieldContainer.style.borderRadius = "4px";
    const headerRow = new import_obsidian.Setting(fieldContainer).setName(`Field ${index + 1}`).addExtraButton((button) => button.setIcon("trash").setTooltip("Remove field").onClick(async () => {
      var _a;
      (_a = source.displayFields) == null ? void 0 : _a.splice(index, 1);
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian.Setting(fieldContainer).setName("Field name").setDesc("Frontmatter field (e.g., timeAsleep, restingHeartRate)").addText((text) => text.setPlaceholder("fieldName").setValue(displayField.field).onChange(async (value) => {
      displayField.field = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(fieldContainer).setName("Label").setDesc("Display label (leave empty to show just the value)").addText((text) => text.setPlaceholder("e.g., Sleep, Resting HR").setValue(displayField.label).onChange(async (value) => {
      displayField.label = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(fieldContainer).setName("Format").setDesc("How to format the value").addDropdown((dropdown) => dropdown.addOption("none", "None (text as-is)").addOption("duration", "Duration (minutes \u2192 Xh Ym)").addOption("number", "Number").setValue(displayField.format).onChange(async (value) => {
      displayField.format = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(fieldContainer).setName("Unit").setDesc("Unit to append (or field name containing the unit)").addText((text) => text.setPlaceholder("e.g., bpm or restingHeartRateUnit").setValue(displayField.unit || displayField.unitField || "").onChange(async (value) => {
      if (value && /^[a-zA-Z][a-zA-Z0-9]*$/.test(value) && value.toLowerCase().includes("unit")) {
        displayField.unitField = value;
        displayField.unit = void 0;
      } else {
        displayField.unit = value || void 0;
        displayField.unitField = void 0;
      }
      await this.plugin.saveSettings();
    }));
  }
};

// src/scanner.ts
var import_obsidian2 = require("obsidian");

// src/utils/dateUtils.ts
function formatDateKey(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}
function parseDateString(dateStr) {
  if (!dateStr) return null;
  const match = dateStr.match(/^(\d{4})-(\d{2})-(\d{2})/);
  if (match) {
    const [, year, month, day] = match;
    return new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
  }
  const parsed = new Date(dateStr);
  if (!isNaN(parsed.getTime())) {
    return parsed;
  }
  return null;
}
function getFirstDayOfMonth(date) {
  return new Date(date.getFullYear(), date.getMonth(), 1);
}
function getLastDayOfMonth(date) {
  return new Date(date.getFullYear(), date.getMonth() + 1, 0);
}
function getDaysInMonth(date) {
  return getLastDayOfMonth(date).getDate();
}
function getWeekNumber(date) {
  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  const dayNum = d.getUTCDay() || 7;
  d.setUTCDate(d.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  return Math.ceil(((d.getTime() - yearStart.getTime()) / 864e5 + 1) / 7);
}
function isSameDay(date1, date2) {
  return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
}
function isToday(date) {
  return isSameDay(date, /* @__PURE__ */ new Date());
}
function getMonthGridDates(date, startWeekOn) {
  const firstDay = getFirstDayOfMonth(date);
  const lastDay = getLastDayOfMonth(date);
  const dates = [];
  let startDayOfWeek = firstDay.getDay();
  if (startWeekOn === "monday") {
    startDayOfWeek = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;
  }
  for (let i = startDayOfWeek - 1; i >= 0; i--) {
    const d = new Date(firstDay);
    d.setDate(d.getDate() - i - 1);
    dates.push(d);
  }
  for (let i = 1; i <= getDaysInMonth(date); i++) {
    dates.push(new Date(date.getFullYear(), date.getMonth(), i));
  }
  const remainingDays = 42 - dates.length;
  for (let i = 1; i <= remainingDays; i++) {
    const d = new Date(lastDay);
    d.setDate(d.getDate() + i);
    dates.push(d);
  }
  return dates;
}
function getWeekDates(date, startWeekOn) {
  const dates = [];
  const current = new Date(date);
  let dayOfWeek = current.getDay();
  if (startWeekOn === "monday") {
    dayOfWeek = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
  }
  current.setDate(current.getDate() - dayOfWeek);
  for (let i = 0; i < 7; i++) {
    dates.push(new Date(current));
    current.setDate(current.getDate() + 1);
  }
  return dates;
}
function formatMonthYear(date) {
  return date.toLocaleDateString("en-US", { month: "long", year: "numeric" });
}
function getWeekdayNames(startWeekOn, short = true) {
  const days = short ? ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] : ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  if (startWeekOn === "monday") {
    const sunday = days.shift();
    days.push(sunday);
  }
  return days;
}
function getPreviousMonth(date) {
  return new Date(date.getFullYear(), date.getMonth() - 1, 1);
}
function getNextMonth(date) {
  return new Date(date.getFullYear(), date.getMonth() + 1, 1);
}
function getPreviousWeek(date) {
  const d = new Date(date);
  d.setDate(d.getDate() - 7);
  return d;
}
function getNextWeek(date) {
  const d = new Date(date);
  d.setDate(d.getDate() + 7);
  return d;
}

// src/scanner.ts
var NoteScanner = class {
  constructor(app) {
    this.eventCache = /* @__PURE__ */ new Map();
    this.eventsByDate = /* @__PURE__ */ new Map();
    this.app = app;
  }
  /**
   * Scan all configured sources and build the event cache
   */
  async scanSources(sources) {
    this.eventCache.clear();
    this.eventsByDate.clear();
    const enabledSources = sources.filter((s) => s.enabled);
    for (const source of enabledSources) {
      const events = await this.scanSource(source);
      this.eventCache.set(source.id, events);
      for (const event of events) {
        const dateKey = formatDateKey(event.date);
        const existing = this.eventsByDate.get(dateKey) || [];
        existing.push(event);
        this.eventsByDate.set(dateKey, existing);
      }
    }
  }
  /**
   * Scan a single source folder for events
   */
  async scanSource(source) {
    const events = [];
    const folder = this.app.vault.getAbstractFileByPath(source.folder);
    if (!folder || !(folder instanceof import_obsidian2.TFolder)) {
      console.warn(`Calendar: Folder not found: ${source.folder}`);
      return events;
    }
    const files = this.getMarkdownFilesInFolder(folder);
    for (const file of files) {
      const event = await this.createEventFromFile(file, source);
      if (event) {
        events.push(event);
      }
    }
    return events;
  }
  /**
   * Get all markdown files in a folder (recursively)
   */
  getMarkdownFilesInFolder(folder) {
    const files = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian2.TFile && child.extension === "md") {
        files.push(child);
      } else if (child instanceof import_obsidian2.TFolder) {
        files.push(...this.getMarkdownFilesInFolder(child));
      }
    }
    return files;
  }
  /**
   * Create a calendar event from a file
   */
  async createEventFromFile(file, source) {
    var _a;
    const cache = this.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (!frontmatter) {
      return null;
    }
    const dateValue = frontmatter[source.dateField];
    if (!dateValue) {
      return null;
    }
    const date = parseDateString(String(dateValue));
    if (!date) {
      return null;
    }
    let title = file.basename;
    if (source.titleField && frontmatter[source.titleField]) {
      const titleValue = frontmatter[source.titleField];
      if (typeof titleValue === "string") {
        title = this.extractDisplayText(titleValue);
      } else if (Array.isArray(titleValue)) {
        title = titleValue.map((v) => this.extractDisplayText(String(v))).join(", ");
      }
    }
    let imagePath;
    if (source.imageField) {
      if (frontmatter[source.imageField]) {
        imagePath = String(frontmatter[source.imageField]);
      }
      if (!imagePath && source.imageFromLinkedNote) {
        const linkedFields = source.imageFromLinkedNote.split(",").map((f) => f.trim()).filter((f) => f);
        for (const linkedField of linkedFields) {
          if (frontmatter[linkedField]) {
            const linkedNotePath = this.resolveLink(frontmatter[linkedField], file.path);
            if (linkedNotePath) {
              const linkedFile = this.app.vault.getAbstractFileByPath(linkedNotePath);
              if (linkedFile instanceof import_obsidian2.TFile) {
                const linkedCache = this.app.metadataCache.getFileCache(linkedFile);
                if ((_a = linkedCache == null ? void 0 : linkedCache.frontmatter) == null ? void 0 : _a[source.imageField]) {
                  imagePath = String(linkedCache.frontmatter[source.imageField]);
                  break;
                }
              }
            }
          }
        }
      }
    }
    return {
      id: file.path,
      title,
      date,
      file,
      source,
      metadata: { ...frontmatter },
      imagePath
    };
  }
  /**
   * Resolve a wikilink to a file path
   */
  resolveLink(linkValue, sourcePath) {
    if (!linkValue) return null;
    const linkStr = String(linkValue);
    const match = linkStr.match(/\[\[([^\]|]+)(?:\|[^\]]+)?\]\]/);
    const linkPath = match ? match[1] : linkStr;
    const linkedFile = this.app.metadataCache.getFirstLinkpathDest(linkPath, sourcePath);
    return (linkedFile == null ? void 0 : linkedFile.path) || null;
  }
  /**
   * Extract display text from a wikilink or plain text
   */
  extractDisplayText(text) {
    const linkMatch = text.match(/\[\[(?:[^\]|]+\|)?([^\]]+)\]\]/);
    if (linkMatch) {
      return linkMatch[1];
    }
    const simpleLinkMatch = text.match(/\[\[([^\]]+)\]\]/);
    if (simpleLinkMatch) {
      const parts = simpleLinkMatch[1].split("/");
      return parts[parts.length - 1];
    }
    return text;
  }
  /**
   * Get events for a specific date
   */
  getEventsForDate(date) {
    const dateKey = formatDateKey(date);
    return this.eventsByDate.get(dateKey) || [];
  }
  /**
   * Get events for a date range
   */
  getEventsInRange(startDate, endDate) {
    const events = [];
    const current = new Date(startDate);
    while (current <= endDate) {
      events.push(...this.getEventsForDate(current));
      current.setDate(current.getDate() + 1);
    }
    return events;
  }
  /**
   * Get all events grouped by date
   */
  getEventsByDate() {
    return this.eventsByDate;
  }
  /**
   * Get events for a specific source
   */
  getEventsForSource(sourceId) {
    return this.eventCache.get(sourceId) || [];
  }
  /**
   * Update events when a file changes
   */
  async updateFile(file, sources) {
    const source = sources.find((s) => s.enabled && file.path.startsWith(s.folder + "/"));
    if (!source) {
      return;
    }
    this.removeEventForFile(file);
    const event = await this.createEventFromFile(file, source);
    if (event) {
      const sourceEvents = this.eventCache.get(source.id) || [];
      sourceEvents.push(event);
      this.eventCache.set(source.id, sourceEvents);
      const dateKey = formatDateKey(event.date);
      const dateEvents = this.eventsByDate.get(dateKey) || [];
      dateEvents.push(event);
      this.eventsByDate.set(dateKey, dateEvents);
    }
  }
  /**
   * Remove events for a deleted file
   */
  removeEventForFile(file) {
    for (const [sourceId, events] of this.eventCache) {
      const filtered = events.filter((e) => e.file.path !== file.path);
      this.eventCache.set(sourceId, filtered);
    }
    for (const [dateKey, events] of this.eventsByDate) {
      const filtered = events.filter((e) => e.file.path !== file.path);
      if (filtered.length > 0) {
        this.eventsByDate.set(dateKey, filtered);
      } else {
        this.eventsByDate.delete(dateKey);
      }
    }
  }
  /**
   * Get count of events per date for a date range
   */
  getEventCountsInRange(startDate, endDate) {
    const counts = /* @__PURE__ */ new Map();
    const current = new Date(startDate);
    while (current <= endDate) {
      const dateKey = formatDateKey(current);
      const events = this.eventsByDate.get(dateKey);
      if (events && events.length > 0) {
        counts.set(dateKey, events.length);
      }
      current.setDate(current.getDate() + 1);
    }
    return counts;
  }
};

// src/CalendarView.ts
var import_obsidian3 = require("obsidian");

// src/components/DayCell.ts
function createDayCell(options) {
  const {
    date,
    currentMonth,
    events,
    onDayClick,
    onEventClick,
    selectedDate
  } = options;
  const cell = document.createElement("div");
  cell.className = "calendar-day-cell";
  cell.setAttribute("data-date", formatDateKey(date));
  if (isToday(date)) {
    cell.addClass("is-today");
  }
  if (date.getMonth() !== currentMonth.getMonth()) {
    cell.addClass("is-other-month");
  }
  if (selectedDate && isSameDay(date, selectedDate)) {
    cell.addClass("is-selected");
  }
  if (events.length > 0) {
    cell.addClass("has-events");
  }
  const dayNumber = cell.createDiv("calendar-day-number");
  dayNumber.textContent = String(date.getDate());
  if (events.length > 0) {
    const eventsContainer = cell.createDiv("calendar-day-events");
    const maxVisible = 3;
    const visibleEvents = events.slice(0, maxVisible);
    visibleEvents.forEach((event) => {
      const eventEl = createEventDot(event, onEventClick);
      eventsContainer.appendChild(eventEl);
    });
    if (events.length > maxVisible) {
      const moreEl = document.createElement("div");
      moreEl.className = "calendar-event-more";
      moreEl.textContent = `+${events.length - maxVisible}`;
      eventsContainer.appendChild(moreEl);
    }
  }
  if (onDayClick) {
    cell.addEventListener("click", (e) => {
      if (e.target.closest(".calendar-event-dot")) {
        return;
      }
      onDayClick(date, events);
    });
  }
  return cell;
}
function createEventDot(event, onClick) {
  const dot = document.createElement("div");
  dot.className = "calendar-event-dot";
  dot.style.backgroundColor = event.source.color;
  dot.setAttribute("title", event.title);
  dot.setAttribute("data-source", event.source.id);
  const text = document.createElement("span");
  text.className = "calendar-event-text";
  text.textContent = event.title;
  dot.appendChild(text);
  if (onClick) {
    dot.addEventListener("click", (e) => {
      e.stopPropagation();
      onClick(event);
    });
  }
  return dot;
}
function createEventList(date, events, onEventClick, onClose) {
  const container = document.createElement("div");
  container.className = "calendar-event-list";
  const header = container.createDiv("calendar-event-list-header");
  const title = header.createEl("h4");
  title.textContent = date.toLocaleDateString("en-US", {
    weekday: "long",
    month: "long",
    day: "numeric"
  });
  if (onClose) {
    const closeBtn = header.createEl("button", { cls: "calendar-event-list-close" });
    closeBtn.innerHTML = "&times;";
    closeBtn.addEventListener("click", onClose);
  }
  if (events.length === 0) {
    const empty = container.createDiv("calendar-event-list-empty");
    empty.textContent = "No events on this day";
  } else {
    const list = container.createDiv("calendar-event-list-items");
    const bySource = /* @__PURE__ */ new Map();
    events.forEach((event) => {
      const sourceEvents = bySource.get(event.source.id) || [];
      sourceEvents.push(event);
      bySource.set(event.source.id, sourceEvents);
    });
    bySource.forEach((sourceEvents, sourceId) => {
      const source = sourceEvents[0].source;
      sourceEvents.forEach((event) => {
        const item = createEventListItem(event, onEventClick);
        list.appendChild(item);
      });
    });
  }
  return container;
}
function createEventListItem(event, onClick) {
  const item = document.createElement("div");
  item.className = "calendar-event-list-item";
  const indicator = item.createDiv("calendar-event-indicator");
  indicator.style.backgroundColor = event.source.color;
  const content = item.createDiv("calendar-event-content");
  const title = content.createDiv("calendar-event-title");
  title.textContent = event.title;
  const metaParts = [event.source.name];
  if (event.source.displayFields) {
    event.source.displayFields.forEach((displayField) => {
      const value = event.metadata[displayField.field];
      if (value !== void 0 && value !== null) {
        const formatted = formatFieldValue(value, displayField, event.metadata);
        if (formatted) {
          metaParts.push(formatted);
        }
      }
    });
  }
  const meta = content.createDiv("calendar-event-meta");
  meta.textContent = metaParts.join(" \xB7 ");
  if (onClick) {
    item.addEventListener("click", () => onClick(event));
    item.addClass("is-clickable");
  }
  return item;
}

// src/components/MonthGrid.ts
function createMonthGrid(options) {
  const {
    currentDate,
    settings,
    eventsByDate,
    onEventClick,
    onNavigate,
    onToday
  } = options;
  const container = document.createElement("div");
  container.className = "calendar-month-view";
  const header = createMonthHeader(currentDate, onNavigate, onToday);
  container.appendChild(header);
  const weekdayRow = createWeekdayHeader(settings.startWeekOn, settings.showWeekNumbers);
  container.appendChild(weekdayRow);
  const grid = document.createElement("div");
  grid.className = "calendar-month-grid";
  if (settings.showWeekNumbers) {
    grid.addClass("show-week-numbers");
  }
  const dates = getMonthGridDates(currentDate, settings.startWeekOn);
  let selectedDate = null;
  let eventListContainer = null;
  let currentWeekStart = 0;
  dates.forEach((date, index) => {
    if (settings.showWeekNumbers && index % 7 === 0) {
      const weekNum = document.createElement("div");
      weekNum.className = "calendar-week-number";
      weekNum.textContent = String(getWeekNumber(date));
      grid.appendChild(weekNum);
    }
    const events = eventsByDate.get(formatDateKey(date)) || [];
    const cell = createDayCell({
      date,
      currentMonth: currentDate,
      events,
      selectedDate,
      onDayClick: (clickedDate, dayEvents) => {
        if (selectedDate && formatDateKey(selectedDate) === formatDateKey(clickedDate)) {
          selectedDate = null;
          eventListContainer == null ? void 0 : eventListContainer.remove();
          eventListContainer = null;
          container.querySelectorAll(".calendar-day-cell.is-selected").forEach((el) => {
            el.removeClass("is-selected");
          });
        } else {
          selectedDate = clickedDate;
          container.querySelectorAll(".calendar-day-cell.is-selected").forEach((el) => {
            el.removeClass("is-selected");
          });
          cell.addClass("is-selected");
          eventListContainer == null ? void 0 : eventListContainer.remove();
          eventListContainer = createEventList(
            clickedDate,
            dayEvents,
            onEventClick,
            () => {
              selectedDate = null;
              eventListContainer == null ? void 0 : eventListContainer.remove();
              eventListContainer = null;
              cell.removeClass("is-selected");
            }
          );
          container.appendChild(eventListContainer);
        }
      },
      onEventClick
    });
    grid.appendChild(cell);
  });
  container.appendChild(grid);
  const legend = createLegend(settings);
  container.appendChild(legend);
  return container;
}
function createMonthHeader(currentDate, onNavigate, onToday) {
  const header = document.createElement("div");
  header.className = "calendar-month-header";
  const prevBtn = document.createElement("button");
  prevBtn.className = "calendar-nav-btn calendar-nav-prev";
  prevBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>';
  prevBtn.setAttribute("aria-label", "Previous month");
  prevBtn.addEventListener("click", () => onNavigate(getPreviousMonth(currentDate)));
  header.appendChild(prevBtn);
  const title = document.createElement("h2");
  title.className = "calendar-month-title";
  title.textContent = formatMonthYear(currentDate);
  header.appendChild(title);
  const nextBtn = document.createElement("button");
  nextBtn.className = "calendar-nav-btn calendar-nav-next";
  nextBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>';
  nextBtn.setAttribute("aria-label", "Next month");
  nextBtn.addEventListener("click", () => onNavigate(getNextMonth(currentDate)));
  header.appendChild(nextBtn);
  const todayBtn = document.createElement("button");
  todayBtn.className = "calendar-today-btn";
  todayBtn.textContent = "Today";
  todayBtn.addEventListener("click", onToday);
  header.appendChild(todayBtn);
  return header;
}
function createWeekdayHeader(startWeekOn, showWeekNumbers) {
  const row = document.createElement("div");
  row.className = "calendar-weekday-header";
  if (showWeekNumbers) {
    row.addClass("show-week-numbers");
    const weekNumHeader = document.createElement("div");
    weekNumHeader.className = "calendar-weekday-cell calendar-week-number-header";
    weekNumHeader.textContent = "Wk";
    row.appendChild(weekNumHeader);
  }
  const weekdays = getWeekdayNames(startWeekOn);
  weekdays.forEach((day) => {
    const cell = document.createElement("div");
    cell.className = "calendar-weekday-cell";
    cell.textContent = day;
    row.appendChild(cell);
  });
  return row;
}
function createLegend(settings) {
  const legend = document.createElement("div");
  legend.className = "calendar-legend";
  settings.sources.filter((s) => s.enabled).forEach((source) => {
    const item = document.createElement("div");
    item.className = "calendar-legend-item";
    const color = document.createElement("span");
    color.className = "calendar-legend-color";
    color.style.backgroundColor = source.color;
    item.appendChild(color);
    const name = document.createElement("span");
    name.className = "calendar-legend-name";
    name.textContent = source.name;
    item.appendChild(name);
    legend.appendChild(item);
  });
  return legend;
}

// src/components/WeekView.ts
function createWeekView(options) {
  const {
    currentDate,
    settings,
    eventsByDate,
    onEventClick,
    onNavigate,
    onToday
  } = options;
  const container = document.createElement("div");
  container.className = "calendar-week-view";
  const header = createWeekHeader(currentDate, settings, onNavigate, onToday);
  container.appendChild(header);
  const grid = document.createElement("div");
  grid.className = "calendar-week-grid";
  const dates = getWeekDates(currentDate, settings.startWeekOn);
  dates.forEach((date) => {
    const dayColumn = createDayColumn(date, eventsByDate, onEventClick);
    grid.appendChild(dayColumn);
  });
  container.appendChild(grid);
  const legend = createLegend2(settings);
  container.appendChild(legend);
  return container;
}
function createWeekHeader(currentDate, settings, onNavigate, onToday) {
  const header = document.createElement("div");
  header.className = "calendar-week-header";
  const dates = getWeekDates(currentDate, settings.startWeekOn);
  const startDate = dates[0];
  const endDate = dates[6];
  const prevBtn = document.createElement("button");
  prevBtn.className = "calendar-nav-btn calendar-nav-prev";
  prevBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>';
  prevBtn.setAttribute("aria-label", "Previous week");
  prevBtn.addEventListener("click", () => onNavigate(getPreviousWeek(currentDate)));
  header.appendChild(prevBtn);
  const title = document.createElement("h2");
  title.className = "calendar-week-title";
  const startStr = startDate.toLocaleDateString("en-US", { month: "short", day: "numeric" });
  const endStr = endDate.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
  title.textContent = `${startStr} - ${endStr}`;
  header.appendChild(title);
  const nextBtn = document.createElement("button");
  nextBtn.className = "calendar-nav-btn calendar-nav-next";
  nextBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>';
  nextBtn.setAttribute("aria-label", "Next week");
  nextBtn.addEventListener("click", () => onNavigate(getNextWeek(currentDate)));
  header.appendChild(nextBtn);
  const todayBtn = document.createElement("button");
  todayBtn.className = "calendar-today-btn";
  todayBtn.textContent = "Today";
  todayBtn.addEventListener("click", onToday);
  header.appendChild(todayBtn);
  return header;
}
function createDayColumn(date, eventsByDate, onEventClick) {
  const column = document.createElement("div");
  column.className = "calendar-week-day";
  if (isToday(date)) {
    column.addClass("is-today");
  }
  const header = column.createDiv("calendar-week-day-header");
  const dayName = header.createDiv("calendar-week-day-name");
  dayName.textContent = date.toLocaleDateString("en-US", { weekday: "short" });
  const dayNum = header.createDiv("calendar-week-day-number");
  dayNum.textContent = String(date.getDate());
  if (isToday(date)) {
    dayNum.addClass("is-today");
  }
  const events = eventsByDate.get(formatDateKey(date)) || [];
  const eventsContainer = column.createDiv("calendar-week-day-events");
  events.forEach((event) => {
    const eventEl = createWeekEventItem(event, onEventClick);
    eventsContainer.appendChild(eventEl);
  });
  if (events.length === 0) {
    const empty = eventsContainer.createDiv("calendar-week-day-empty");
    empty.textContent = "-";
  }
  return column;
}
function createWeekEventItem(event, onClick) {
  const item = document.createElement("div");
  item.className = "calendar-week-event";
  item.style.borderLeftColor = event.source.color;
  item.style.backgroundColor = `${event.source.color}15`;
  const title = item.createDiv("calendar-week-event-title");
  title.textContent = event.title;
  const meta = item.createDiv("calendar-week-event-source");
  const metaParts = [event.source.name];
  if (event.source.displayFields) {
    event.source.displayFields.forEach((displayField) => {
      const value = event.metadata[displayField.field];
      if (value !== void 0 && value !== null) {
        const formatted = formatFieldValue(value, displayField, event.metadata);
        if (formatted) {
          metaParts.push(formatted);
        }
      }
    });
  }
  meta.textContent = metaParts.join(" \xB7 ");
  item.addEventListener("click", () => onClick(event));
  return item;
}
function createLegend2(settings) {
  const legend = document.createElement("div");
  legend.className = "calendar-legend";
  settings.sources.filter((s) => s.enabled).forEach((source) => {
    const item = document.createElement("div");
    item.className = "calendar-legend-item";
    const color = document.createElement("span");
    color.className = "calendar-legend-color";
    color.style.backgroundColor = source.color;
    item.appendChild(color);
    const name = document.createElement("span");
    name.className = "calendar-legend-name";
    name.textContent = source.name;
    item.appendChild(name);
    legend.appendChild(item);
  });
  return legend;
}

// src/components/ListView.ts
function createListView(options) {
  const {
    currentDate,
    settings,
    eventsByDate,
    onEventClick,
    onNavigate,
    onToday,
    vaultAdapter
  } = options;
  const container = document.createElement("div");
  container.className = "calendar-list-view";
  const header = createListHeader(currentDate, onNavigate, onToday);
  container.appendChild(header);
  const startDate = getFirstDayOfMonth(currentDate);
  const endDate = getLastDayOfMonth(currentDate);
  const eventsInMonth = [];
  const current = new Date(startDate);
  while (current <= endDate) {
    const dateKey = formatDateKey(current);
    const events = eventsByDate.get(dateKey);
    if (events && events.length > 0) {
      eventsInMonth.push({
        date: new Date(current),
        events: [...events]
      });
    }
    current.setDate(current.getDate() + 1);
  }
  const list = container.createDiv("calendar-list-content");
  if (eventsInMonth.length === 0) {
    const empty = list.createDiv("calendar-list-empty");
    empty.textContent = "No events this month";
  } else {
    eventsInMonth.forEach(({ date, events }) => {
      const dateGroup = createDateGroup(date, events, onEventClick, vaultAdapter);
      list.appendChild(dateGroup);
    });
  }
  const totalEvents = eventsInMonth.reduce((sum, { events }) => sum + events.length, 0);
  const summary = container.createDiv("calendar-list-summary");
  summary.textContent = `${totalEvents} event${totalEvents !== 1 ? "s" : ""} in ${formatMonthYear(currentDate)}`;
  const legend = createLegend3(settings);
  container.appendChild(legend);
  return container;
}
function createListHeader(currentDate, onNavigate, onToday) {
  const header = document.createElement("div");
  header.className = "calendar-list-header";
  const prevBtn = document.createElement("button");
  prevBtn.className = "calendar-nav-btn calendar-nav-prev";
  prevBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>';
  prevBtn.setAttribute("aria-label", "Previous month");
  prevBtn.addEventListener("click", () => onNavigate(getPreviousMonth(currentDate)));
  header.appendChild(prevBtn);
  const title = document.createElement("h2");
  title.className = "calendar-list-title";
  title.textContent = formatMonthYear(currentDate);
  header.appendChild(title);
  const nextBtn = document.createElement("button");
  nextBtn.className = "calendar-nav-btn calendar-nav-next";
  nextBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>';
  nextBtn.setAttribute("aria-label", "Next month");
  nextBtn.addEventListener("click", () => onNavigate(getNextMonth(currentDate)));
  header.appendChild(nextBtn);
  const todayBtn = document.createElement("button");
  todayBtn.className = "calendar-today-btn";
  todayBtn.textContent = "Today";
  todayBtn.addEventListener("click", onToday);
  header.appendChild(todayBtn);
  return header;
}
function createDateGroup(date, events, onEventClick, vaultAdapter) {
  const group = document.createElement("div");
  group.className = "calendar-list-date-group";
  const dateHeader = group.createDiv("calendar-list-date-header");
  const dayName = dateHeader.createSpan("calendar-list-date-day");
  dayName.textContent = date.toLocaleDateString("en-US", { weekday: "short" });
  const dayNum = dateHeader.createSpan("calendar-list-date-number");
  dayNum.textContent = String(date.getDate());
  const monthName = dateHeader.createSpan("calendar-list-date-month");
  monthName.textContent = date.toLocaleDateString("en-US", { month: "short" });
  const eventsContainer = group.createDiv("calendar-list-events");
  events.forEach((event) => {
    const eventEl = createListEventItem(event, onEventClick, vaultAdapter);
    eventsContainer.appendChild(eventEl);
  });
  return group;
}
function createListEventItem(event, onClick, vaultAdapter) {
  const item = document.createElement("div");
  item.className = "calendar-list-event";
  const hasImage = !!event.imagePath;
  let highlightValue = void 0;
  let highlightFieldIndex = -1;
  if (event.source.highlightField) {
    const highlightFields = event.source.highlightField.split(",").map((f) => f.trim()).filter((f) => f);
    for (let i = 0; i < highlightFields.length; i++) {
      const field = highlightFields[i];
      if (event.metadata[field] !== void 0 && event.metadata[field] !== null) {
        highlightValue = event.metadata[field];
        highlightFieldIndex = i;
        break;
      }
    }
  }
  const hasHighlight = !hasImage && highlightValue !== void 0 && highlightValue !== null;
  let highlightUnit;
  if (event.source.highlightUnit && highlightFieldIndex >= 0) {
    const units = event.source.highlightUnit.split(",").map((u) => u.trim());
    highlightUnit = units[highlightFieldIndex] || units[0];
  } else if (event.source.highlightUnit) {
    highlightUnit = event.source.highlightUnit.trim();
  }
  if (hasImage || hasHighlight) {
    item.addClass("has-image");
  }
  if (hasImage && vaultAdapter && event.imagePath) {
    const imageContainer = item.createDiv("calendar-list-event-image");
    const img = imageContainer.createEl("img");
    try {
      img.src = vaultAdapter.getResourcePath(event.imagePath);
      img.alt = event.title;
      img.onerror = () => {
        imageContainer.style.display = "none";
        item.removeClass("has-image");
      };
    } catch (e) {
      imageContainer.style.display = "none";
    }
  } else if (hasHighlight) {
    const highlightBox = item.createDiv("calendar-list-event-highlight");
    highlightBox.style.backgroundColor = event.source.color;
    const format = event.source.highlightFormat || "none";
    if (format === "duration") {
      const numValue = typeof highlightValue === "number" ? highlightValue : parseFloat(String(highlightValue));
      if (!isNaN(numValue)) {
        const hours = Math.floor(numValue / 60);
        const mins = Math.round(numValue % 60);
        if (hours > 0) {
          const hoursEl = highlightBox.createDiv("calendar-highlight-hours");
          hoursEl.textContent = `${hours}h`;
        }
        const minsEl = highlightBox.createDiv("calendar-highlight-mins");
        minsEl.textContent = `${mins}m`;
      } else {
        const valueEl = highlightBox.createDiv("calendar-highlight-value");
        valueEl.textContent = String(highlightValue);
      }
    } else {
      let displayValue = String(highlightValue);
      if (format === "number") {
        const numValue = typeof highlightValue === "number" ? highlightValue : parseFloat(String(highlightValue));
        if (!isNaN(numValue)) {
          displayValue = numValue.toLocaleString();
        }
      }
      const valueEl = highlightBox.createDiv("calendar-highlight-value");
      valueEl.textContent = displayValue;
      if (highlightUnit) {
        const unitEl = highlightBox.createDiv("calendar-highlight-unit");
        unitEl.textContent = highlightUnit;
      }
    }
  }
  const indicator = item.createDiv("calendar-list-event-indicator");
  indicator.style.backgroundColor = event.source.color;
  const content = item.createDiv("calendar-list-event-content");
  const title = content.createDiv("calendar-list-event-title");
  title.textContent = event.title;
  const meta = content.createDiv("calendar-list-event-meta");
  const sourceBadge = meta.createSpan("calendar-list-event-source");
  sourceBadge.textContent = event.source.name;
  sourceBadge.style.backgroundColor = `${event.source.color}20`;
  sourceBadge.style.color = event.source.color;
  if (event.source.displayFields && event.source.displayFields.length > 0) {
    const fieldsContainer = content.createDiv("calendar-list-event-fields");
    event.source.displayFields.forEach((displayField) => {
      const value = event.metadata[displayField.field];
      if (value !== void 0 && value !== null) {
        const formatted = formatFieldValue(value, displayField, event.metadata);
        if (formatted) {
          const fieldRow = fieldsContainer.createDiv("calendar-list-event-field-row");
          fieldRow.textContent = formatted;
        }
      }
    });
  }
  item.addEventListener("click", () => onClick(event));
  return item;
}
function createLegend3(settings) {
  const legend = document.createElement("div");
  legend.className = "calendar-legend";
  settings.sources.filter((s) => s.enabled).forEach((source) => {
    const item = document.createElement("div");
    item.className = "calendar-legend-item";
    const color = document.createElement("span");
    color.className = "calendar-legend-color";
    color.style.backgroundColor = source.color;
    item.appendChild(color);
    const name = document.createElement("span");
    name.className = "calendar-legend-name";
    name.textContent = source.name;
    item.appendChild(name);
    legend.appendChild(item);
  });
  return legend;
}

// src/CalendarView.ts
var VIEW_TYPE_CALENDAR = "calendar-view";
var CalendarView = class extends import_obsidian3.ItemView {
  // Track which sources are visible
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.currentDate = /* @__PURE__ */ new Date();
    this.viewMode = plugin.settings.defaultView;
    this.visibleSources = /* @__PURE__ */ new Set();
    this.keydownHandler = this.handleKeydown.bind(this);
  }
  getViewType() {
    return VIEW_TYPE_CALENDAR;
  }
  getDisplayText() {
    return "Calendar";
  }
  getIcon() {
    return "calendar";
  }
  async onOpen() {
    this.containerEl = this.contentEl;
    this.containerEl.empty();
    this.containerEl.addClass("calendar-view-container");
    this.visibleSources = new Set(
      this.plugin.settings.sources.filter((s) => s.enabled).map((s) => s.id)
    );
    this.containerEl.addEventListener("keydown", this.keydownHandler);
    this.containerEl.setAttribute("tabindex", "0");
    await this.render();
  }
  async onClose() {
    this.containerEl.removeEventListener("keydown", this.keydownHandler);
    this.containerEl.empty();
  }
  handleKeydown(e) {
    if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
      return;
    }
    switch (e.key) {
      case "ArrowLeft":
        e.preventDefault();
        this.previousPeriod();
        break;
      case "ArrowRight":
        e.preventDefault();
        this.nextPeriod();
        break;
      case "t":
      case "T":
        e.preventDefault();
        this.goToToday();
        break;
      case "m":
      case "M":
        e.preventDefault();
        this.setViewMode("month");
        break;
      case "w":
      case "W":
        e.preventDefault();
        this.setViewMode("week");
        break;
      case "l":
      case "L":
        e.preventDefault();
        this.setViewMode("list");
        break;
    }
  }
  async render() {
    this.containerEl.empty();
    const viewTabs = this.createViewTabs();
    this.containerEl.appendChild(viewTabs);
    const filterBar = this.createFilterBar();
    this.containerEl.appendChild(filterBar);
    const content = document.createElement("div");
    content.className = "calendar-content";
    const allEventsByDate = this.plugin.scanner.getEventsByDate();
    const eventsByDate = this.filterEventsBySource(allEventsByDate);
    switch (this.viewMode) {
      case "month":
        const monthView = createMonthGrid({
          currentDate: this.currentDate,
          settings: this.plugin.settings,
          eventsByDate,
          onEventClick: (event) => this.openEvent(event),
          onNavigate: (date) => this.navigateTo(date),
          onToday: () => this.goToToday()
        });
        content.appendChild(monthView);
        break;
      case "week":
        const weekView = createWeekView({
          currentDate: this.currentDate,
          settings: this.plugin.settings,
          eventsByDate,
          onEventClick: (event) => this.openEvent(event),
          onNavigate: (date) => this.navigateTo(date),
          onToday: () => this.goToToday()
        });
        content.appendChild(weekView);
        break;
      case "list":
        const listView = createListView({
          currentDate: this.currentDate,
          settings: this.plugin.settings,
          eventsByDate,
          onEventClick: (event) => this.openEvent(event),
          onNavigate: (date) => this.navigateTo(date),
          onToday: () => this.goToToday(),
          vaultAdapter: {
            getResourcePath: (path) => this.app.vault.adapter.getResourcePath(path)
          }
        });
        content.appendChild(listView);
        break;
    }
    this.containerEl.appendChild(content);
  }
  createViewTabs() {
    const tabs = document.createElement("div");
    tabs.className = "calendar-view-tabs";
    const modes = [
      { id: "month", label: "Month" },
      { id: "week", label: "Week" },
      { id: "list", label: "List" }
    ];
    modes.forEach((mode) => {
      const tab = document.createElement("button");
      tab.className = "calendar-view-tab";
      if (mode.id === this.viewMode) {
        tab.addClass("is-active");
      }
      tab.textContent = mode.label;
      tab.addEventListener("click", () => {
        this.viewMode = mode.id;
        this.render();
      });
      tabs.appendChild(tab);
    });
    return tabs;
  }
  createFilterBar() {
    const filterBar = document.createElement("div");
    filterBar.className = "calendar-filter-bar";
    const enabledSources = this.plugin.settings.sources.filter((s) => s.enabled);
    const allBtn = document.createElement("button");
    allBtn.className = "calendar-filter-btn calendar-filter-all";
    if (this.visibleSources.size === enabledSources.length) {
      allBtn.addClass("is-active");
    }
    allBtn.textContent = "All";
    allBtn.addEventListener("click", () => {
      if (this.visibleSources.size === enabledSources.length) {
        this.visibleSources.clear();
      } else {
        enabledSources.forEach((s) => this.visibleSources.add(s.id));
      }
      this.render();
    });
    filterBar.appendChild(allBtn);
    enabledSources.forEach((source) => {
      const btn = document.createElement("button");
      btn.className = "calendar-filter-btn";
      const isVisible = this.visibleSources.has(source.id);
      if (isVisible) {
        btn.addClass("is-active");
        btn.style.backgroundColor = source.color;
        btn.style.borderColor = source.color;
        btn.style.color = "white";
      } else {
        btn.style.borderColor = source.color;
        btn.style.color = source.color;
      }
      btn.textContent = source.name;
      btn.addEventListener("click", () => {
        if (this.visibleSources.has(source.id)) {
          this.visibleSources.delete(source.id);
        } else {
          this.visibleSources.add(source.id);
        }
        this.render();
      });
      filterBar.appendChild(btn);
    });
    return filterBar;
  }
  filterEventsBySource(eventsByDate) {
    const filtered = /* @__PURE__ */ new Map();
    for (const [dateKey, events] of eventsByDate) {
      const filteredEvents = events.filter((e) => this.visibleSources.has(e.source.id));
      if (filteredEvents.length > 0) {
        filtered.set(dateKey, filteredEvents);
      }
    }
    return filtered;
  }
  async openEvent(event) {
    const leaf = this.app.workspace.getLeaf(false);
    await leaf.openFile(event.file);
  }
  navigateTo(date) {
    this.currentDate = date;
    this.render();
  }
  goToToday() {
    this.currentDate = /* @__PURE__ */ new Date();
    this.render();
  }
  nextPeriod() {
    if (this.viewMode === "month") {
      this.currentDate = new Date(this.currentDate.getFullYear(), this.currentDate.getMonth() + 1, 1);
    } else {
      this.currentDate = new Date(this.currentDate.getTime() + 7 * 24 * 60 * 60 * 1e3);
    }
    this.render();
  }
  previousPeriod() {
    if (this.viewMode === "month") {
      this.currentDate = new Date(this.currentDate.getFullYear(), this.currentDate.getMonth() - 1, 1);
    } else {
      this.currentDate = new Date(this.currentDate.getTime() - 7 * 24 * 60 * 60 * 1e3);
    }
    this.render();
  }
  setViewMode(mode) {
    this.viewMode = mode;
    this.render();
  }
  async refresh() {
    await this.render();
  }
};

// src/main.ts
var CalendarPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    console.log("Loading Calendar Plugin");
    await this.loadSettings();
    this.scanner = new NoteScanner(this.app);
    this.registerView(VIEW_TYPE_CALENDAR, (leaf) => new CalendarView(leaf, this));
    this.addRibbonIcon("calendar", "Open Calendar", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-calendar-view",
      name: "Open calendar view",
      callback: () => this.activateView()
    });
    this.addCommand({
      id: "calendar-go-to-today",
      name: "Go to today",
      callback: () => {
        const view = this.getCalendarView();
        if (view) {
          view.goToToday();
        }
      }
    });
    this.addCommand({
      id: "calendar-next-period",
      name: "Next month/week",
      callback: () => {
        const view = this.getCalendarView();
        if (view) {
          view.nextPeriod();
        }
      }
    });
    this.addCommand({
      id: "calendar-previous-period",
      name: "Previous month/week",
      callback: () => {
        const view = this.getCalendarView();
        if (view) {
          view.previousPeriod();
        }
      }
    });
    this.addCommand({
      id: "calendar-view-month",
      name: "Switch to month view",
      callback: () => {
        const view = this.getCalendarView();
        if (view) {
          view.setViewMode("month");
        }
      }
    });
    this.addCommand({
      id: "calendar-view-week",
      name: "Switch to week view",
      callback: () => {
        const view = this.getCalendarView();
        if (view) {
          view.setViewMode("week");
        }
      }
    });
    this.addCommand({
      id: "calendar-view-list",
      name: "Switch to list view",
      callback: () => {
        const view = this.getCalendarView();
        if (view) {
          view.setViewMode("list");
        }
      }
    });
    this.addSettingTab(new CalendarSettingTab(this.app, this));
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        this.handleFileChange(file);
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => {
        if (file instanceof import_obsidian4.TFile) {
          this.handleFileDelete(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian4.TFile) {
          this.handleFileRename(file, oldPath);
        }
      })
    );
    this.app.workspace.onLayoutReady(async () => {
      await this.scanner.scanSources(this.settings.sources);
    });
  }
  onunload() {
    console.log("Unloading Calendar Plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.scanner.scanSources(this.settings.sources);
    await this.refreshViewIfAvailable();
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_CALENDAR);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeaf("tab");
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_CALENDAR, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  getCalendarView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CALENDAR);
    if (leaves.length > 0) {
      return leaves[0].view;
    }
    return null;
  }
  async refreshViewIfAvailable() {
    const view = this.getCalendarView();
    if (view && typeof view.refresh === "function") {
      await view.refresh();
    }
  }
  async handleFileChange(file) {
    const isTracked = this.settings.sources.some(
      (s) => s.enabled && file.path.startsWith(s.folder + "/")
    );
    if (isTracked) {
      await this.scanner.updateFile(file, this.settings.sources);
      await this.refreshViewIfAvailable();
    }
  }
  async handleFileDelete(file) {
    this.scanner.removeEventForFile(file);
    await this.refreshViewIfAvailable();
  }
  async handleFileRename(file, oldPath) {
    const oldFile = { path: oldPath };
    this.scanner.removeEventForFile(oldFile);
    await this.scanner.updateFile(file, this.settings.sources);
    await this.refreshViewIfAvailable();
  }
};
